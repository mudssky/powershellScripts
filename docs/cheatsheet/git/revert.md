`git revert` 是回滚公共代码最安全的方式，但它并非“无痛”的，甚至在某些特定场景下会引发复杂的逻辑陷阱。

以下是使用 `git revert` 时必须注意的 5 个核心事项：

---

### 1. ⚠️ 必须面对冲突 (Conflicts)

`git revert` 本质上是一个“反向修改”。如果后来提交的代码依赖于你想撤销的那部分代码，Git 就会报冲突。

* **现象：** 执行 `git revert` 后，终端提示 `CONFLICT`。
* **应对：**
    1. 你需要像合并代码一样，打开冲突文件，手动决定保留哪些代码。
    2. 解决后执行 `git add .`。
    3. 执行 `git revert --continue` 完成操作。
* **切记：** 解决冲突时要非常小心，确认你是在“恢复旧逻辑”而不是“删除了新功能”。

---

### 2. ☠️ 撤销 Merge Commit 的陷阱 (Revert a Merge)

这是 `git revert` 最复杂、最容易翻车的场景。
默认情况下，你不能直接 revert 一个合并节点，因为 Git 不知道应该保留哪条分支的内容。

* **必须指定主线 (`-m`)：**
    如果你要撤销一个 PR/Merge，必须使用 `-m` 参数指定“保留哪一边”。
    通常主分支（Main/Master）是父节点 1。

    ```bash
    git revert -m 1 <merge_commit_hash>
    ```

* **后果：** 这会撤销该 Merge 引入的所有更改，让代码回到合并前的状态。

---

### 3. 🚫 “以后再合并”的陷阱 (The Revert-of-Merge Trap)

**这是一个极其经典的问题：**
如果你 Revert 了一个 Feature 分支的合并（比如因为它有 Bug），当你修好这个 Feature 分支，**再次**试图把它合并回主分支时，**Git 会认为那些代码已经合并过了，从而什么都不会发生，或者丢失代码。**

* **原因：** Git 的合并算法是看 commit ID 的。虽然你 Revert 了代码（内容变了），但原始的 commit ID 还在历史里。Git 看到：“哦，这个分支的 commit 已经在主分支里了，那我跳过。”
* **正确做法（Revert the Revert）：**
    当你修复好 Bug 准备再次合并时，你需要**撤销掉你之前的那个撤销操作**（即对 `Revert Commit` 再做一次 `git revert`），而不是直接 Merge 原分支。

---

### 4. 🔒 敏感数据无法清除

`git revert` 只是在历史末端增加一个新的提交，**它不会删除历史记录**。

* **注意事项：** 如果你是因为不小心提交了 **密码、API Key 或 巨大的二进制文件** 而想回滚，**千万不要用 `git revert`**。
* **原因：** 你的密码依然存在于之前的 commit 历史中，黑客依然可以翻阅历史找到它。
* **正确做法：** 这种情况必须使用 `git filter-branch` 或 [BFG Repo-Cleaner](https://rtyley.github.io/bfg-repo-cleaner/) 来彻底清洗历史（也就是需要强制推送）。

---

### 5. 📋 批量撤销的顺序

如果你想撤销最近的 3 个提交（A -> B -> C，C 是最新的），不要跳着撤销，也不要按时间正序撤销。

* **最佳实践：** 遵循 **后进先出 (LIFO)** 原则。
    先撤销 C，再撤销 B，最后撤销 A。

    ```bash
    # 撤销最近三次提交
    git revert HEAD HEAD~1 HEAD~2
    ```

    或者使用范围（注意范围不包含起点，所以要多算一个）：

    ```bash
    git revert HEAD...HEAD~3
    ```

    如果不按顺序，极大概率会引发极其痛苦的代码冲突。

### 总结

* **普通回滚**：放心用 `git revert`，做好解冲突的准备。
* **回滚 Merge**：小心使用 `-m 1`，并且记住，下次再想合并这个分支时，需要“负负得正”（Revert the Revert）。
* **删密码**：别用 `revert`，没用。
