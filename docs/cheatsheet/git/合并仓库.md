将一个 Git 仓库（我们称为 `Source Repo`）整合到另一个仓库（`Target Repo`）中，通常有三种主要策略。选择哪种取决于你整合的目的。

以下是针对不同场景的最佳实践指南。

---

### 场景一：永久合并（迁移/Monorepo）—— **最推荐**

**目标：** 你想将 `Source Repo` 的所有代码和**完整的提交历史**永久移动到 `Target Repo` 中。合并后，`Source Repo` 将不再独立维护。
**适用：** 项目合并、从多仓库迁移到单体仓库（Monorepo）。

#### 最佳实践步骤

为了防止文件冲突（例如两个仓库都有 `README.md`），最佳做法是先在源仓库中将所有文件移动到一个子目录中，然后再合并。

**1. 准备源仓库 (Source Repo)**
在这一步，我们重写源仓库的文件结构，使其适应目标仓库。
*(注意：请在源仓库的副本上操作，以免误伤原项目)*

```bash
# 进入源仓库目录
cd path/to/source-repo

# 创建一个目录，用来存放该仓库的所有内容（例如命名为 project-a）
mkdir project-a

# 将所有文件移动到该目录中（排除 .git 目录）
# Linux/Mac:
git mv !(project-a|.git) project-a
# Windows (PowerShell) 或手动操作:
# 建议手动全选移动，或者使用 git mv 命令逐个移动文件夹

# 提交变更
git add .
git commit -m "Move all files to subdir project-a for migration"
```

**2. 在目标仓库 (Target Repo) 执行合并**
现在进入你想要保留的目标仓库。

```bash
# 进入目标仓库目录
cd path/to/target-repo

# 添加源仓库为本地的一个远程地址 (remote)
# path/to/source-repo 可以是本地路径，也可以是 git URL
git remote add source-repo-alias ../path/to/source-repo

# 获取源仓库的数据
git fetch source-repo-alias

# 合并源仓库的分支（通常是 main 或 master）
# 关键参数：--allow-unrelated-histories (允许合并不相关的历史记录)
git merge source-repo-alias/main --allow-unrelated-histories -m "Merge Project A into Target Repo"

# 此时，你会看到 project-a 文件夹出现在了目标仓库中，且保留了所有历史记录。
```

**3. 清理**

```bash
# 移除临时的远程地址
git remote remove source-repo-alias

# 推送到远程服务器
git push origin main
```

---

### 场景二：双向同步（Git Subtree）

**目标：** `Source Repo` 仍然是一个独立的项目，但你希望将其代码包含在 `Target Repo` 中，并且希望能够双向同步修改（在父仓库修改子项目代码并推送回去）。
**适用：** 通用库（Library）、插件，或者你没有权限完全废弃原仓库的情况。

#### 最佳实践步骤

Git Subtree 比 Submodule 更易于管理，因为代码是实实在在存在于父仓库中的，克隆父仓库的人不需要做额外操作。

**1. 添加 Subtree**

```bash
cd path/to/target-repo

# 添加并拉取内容
# --prefix=project-a 指定存放的子目录
git subtree add --prefix=project-a <source-repo-url> main --squash
```

*注意：`--squash` 参数是可选的。如果你想把子项目的历史压缩成一个提交，保持主仓库历史整洁，就加上它；如果想保留子项目的完整琐碎历史，就不加。推荐加上。*

**2. 拉取更新 (Update)**
当源仓库有更新时：

```bash
git subtree pull --prefix=project-a <source-repo-url> main --squash
```

**3. 推送修改 (Push)**
如果你在父仓库里修改了 `project-a` 的代码，想推回源仓库：

```bash
git subtree push --prefix=project-a <source-repo-url> main
```

---

### 场景三：仅引用（Git Submodule）

**目标：** 你只想在 `Target Repo` 中引用 `Source Repo` 的某个特定版本，不想直接管理其代码文件。
**适用：** 严格的依赖管理，子项目体积巨大，或者子项目是第三方维护的。

*警告：Submodule 在开发体验上通常被认为是“最痛苦”的，因为协同开发时容易因为忘记更新指针而导致问题。除非有强理由，否则尽量避免。*

#### 最佳实践步骤

**1. 添加 Submodule**

```bash
git submodule add <source-repo-url> project-a
```

**2. 克隆包含 Submodule 的仓库**
别人下载你的项目时，必须使用递归克隆，否则子目录是空的：

```bash
git clone --recursive <target-repo-url>
```

或者如果已经克隆了：

```bash
git submodule update --init --recursive
```

---

### 总结建议

| 需求 | 推荐方案 | 理由 |
| :--- | :--- | :--- |
| **彻底合并两个项目** | **场景一 (Merge with History)** | 永久保留历史，像原生代码一样管理，文件级搜索方便。 |
| **引入公共库/组件** | **场景二 (Git Subtree)** | 既能包含代码，又能保留独立更新的能力，且对协作者透明（不需要特殊命令）。 |
| **引用第三方大型项目** | **场景三 (Git Submodule)** | 保持主仓库体积小，严格版本控制。 |

**专家提示：**
如果在执行 **场景一** 时，源仓库历史非常复杂或巨大，可以考虑使用工具如 `git-filter-repo` (Python 工具，比 git filter-branch 快且安全) 来先清洗源仓库（例如删除大文件、删除敏感信息）再进行合并。

---

### 实战案例：合并 AHK 脚本仓库到 Monorepo

#### 准备工作

假设你本地有两个文件夹：

1. `monorepo-project` (主项目，pnpm monorepo)
2. `ahk-scripts` (副项目，ahk 脚本)

#### 第一步：处理 AHK 仓库（调整目录结构）

为了避免合并后文件散落在 Monorepo 的根目录，我们需要先在 AHK 仓库中把所有文件挪到一个与目标路径一致的子文件夹里。

1. 进入 AHK 仓库：

    ```bash
    cd ahk-scripts
    ```

2. 为了安全起见，切出一个临时分支（可选，但推荐）：

    ```bash
    git checkout -b prepare-merge
    ```

3. 创建目标目录结构 `scripts/ahk`：

    ```bash
    mkdir -p scripts/ahk
    ```

4. 将 AHK 仓库中**除了** `.git` 和 新建的 `scripts` 文件夹以外的所有文件移动到 `scripts/ahk` 中。
    * *注意：可以使用 git mv 命令，或者在文件管理器中手动移动后 stage。*

    ```bash
    # 假设你的 ahk 都在根目录，这一步将它们移入子目录
    git mv ./* scripts/ahk/
    # 如果有 .gitignore 等隐藏文件，也要记得移动
    # git mv .gitignore scripts/ahk/
    ```

    *(此时，你的 AHK 仓库根目录下应该只剩下一个 `scripts` 文件夹)*

5. 提交更改：

    ```bash
    git add .
    git commit -m "Refactor: move all files to scripts/ahk for monorepo merge"
    ```

#### 第二步：在 Monorepo 中进行合并

现在回到你的 pnpm monorepo 项目进行操作。

1. 进入 Monorepo 目录：

    ```bash
    cd ../monorepo-project
    ```

2. 将 AHK 仓库添加为本地的 git remote 源：

    ```bash
    # 这里的路径指向你本地的 ahk 仓库路径
    git remote add ahk_origin ../ahk-scripts
    ```

3. 拉取数据：

    ```bash
    git fetch ahk_origin
    ```

4. **关键步骤**：合并 AHK 仓库的临时分支。
    因为两个仓库历史完全不同，必须加上 `--allow-unrelated-histories` 参数。

    ```bash
    git merge ahk_origin/prepare-merge --allow-unrelated-histories -m "Merge: integrate ahk scripts into scripts/ahk"
    ```

5. 解决冲突（如果有）：
    * 通常如果你在第一步正确移动了文件，几乎不会有文件冲突。
    * 如果有冲突，解决后 `git add` 并 `git commit`。

6. 清理 Remote：
    合并完成后，刚才添加的 remote 就不需要了。

    ```bash
    git remote remove ahk_origin
    ```

#### 第三步：pnpm Monorepo 配置（可选）

虽然文件已经过来了，但由于是在 `pnpm monorepo` 环境下，你可能需要做一些配置：

**情况 A：如果这只是单纯的脚本文件夹（不作为 npm 包）**
你不需要做任何事。`scripts/ahk` 里的代码已经存在，你可以直接在根目录的 `package.json` 中添加 script 来调用它，例如：

```json
// monorepo-project/package.json
{
  "scripts": {
    "ahk:run": "AutoHotkey.exe scripts/ahk/main.ahk"
  }
}
```

**情况 B：如果你希望这个文件夹也被 pnpm 管理（作为 workspace package）**
如果这个文件夹里会有 `package.json`（例如用于安装 prettier 来格式化 ahk 代码，或者配合 husky 钩子），你需要：

1. 在 `scripts/ahk` 下创建一个 `package.json`：

    ```json
    {
      "name": "@my-repo/ahk-scripts",
      "version": "1.0.0",
      "private": true
    }
    ```

2. 确保根目录的 `pnpm-workspace.yaml` 包含了这个路径：

    ```yaml
    packages:
      - 'apps/*'
      - 'packages/*'
      - 'scripts/*'  <-- 确保包含这一行
    ```

3. 运行 `pnpm install` 链接依赖。

#### 总结

现在，你的 AHK 项目已经完美融合进 Monorepo 的 `scripts/ahk` 目录中，并且以前的 Git 修改记录（Log）全部都在，以后你只需要在这个 Monorepo 仓库中统一提交代码即可。
