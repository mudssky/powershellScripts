<thought id="performance-optimization">
  <exploration>
    ## Go性能优化思维探索
    
    ### 性能瓶颈识别
    - **CPU密集型**：算法复杂度、循环优化、并行计算
    - **内存密集型**：内存分配、垃圾回收、内存泄漏
    - **I/O密集型**：网络延迟、磁盘读写、数据库查询
    - **并发瓶颈**：锁竞争、goroutine调度、channel阻塞
    
    ### 性能测量方法
    - **Benchmark测试**：使用testing包进行性能基准测试
    - **pprof分析**：CPU、内存、goroutine、阻塞分析
    - **trace分析**：goroutine调度、GC行为、系统调用
    - **监控指标**：QPS、延迟、内存使用、错误率
    
    ### 优化策略分类
    - **算法优化**：选择更高效的算法和数据结构
    - **内存优化**：减少分配、对象池、内存复用
    - **并发优化**：合理使用goroutine、避免锁竞争
    - **I/O优化**：批处理、缓存、连接池
  </exploration>
  
  <reasoning>
    ## 性能优化决策逻辑
    
    ### 优化优先级评估
    - **影响范围**：优化对整体性能的提升程度
    - **实现成本**：开发时间和代码复杂度增加
    - **维护成本**：优化后代码的可维护性
    - **风险评估**：优化可能引入的bug和稳定性问题
    
    ### 内存优化策略
    - **减少分配**：复用slice、使用sync.Pool、避免不必要的string转换
    - **控制GC**：合理设置GOGC、减少指针使用、批量处理
    - **内存布局**：结构体字段对齐、减少内存碎片
    - **泄漏预防**：及时释放资源、避免循环引用
    
    ### 并发优化思路
    - **goroutine管理**：控制数量、避免泄漏、合理生命周期
    - **同步机制**：选择合适的同步原语、减少锁粒度
    - **负载均衡**：工作窃取、任务分发、资源隔离
    - **背压处理**：流量控制、缓冲区管理、降级策略
    
    ### I/O优化方案
    - **连接复用**：HTTP keep-alive、数据库连接池
    - **批量操作**：批量读写、pipeline、事务合并
    - **异步处理**：非阻塞I/O、事件驱动、回调机制
    - **缓存策略**：本地缓存、分布式缓存、缓存预热
  </reasoning>
  
  <challenge>
    ## 性能优化挑战
    
    ### 过度优化陷阱
    - 如何避免过早优化？
    - 如何平衡性能和代码可读性？
    - 何时停止优化？
    
    ### 测量准确性
    - 如何设计准确的性能测试？
    - 如何排除环境因素干扰？
    - 如何模拟真实负载？
    
    ### 优化副作用
    - 优化可能引入哪些新问题？
    - 如何确保优化的稳定性？
    - 如何处理性能回归？
  </challenge>
  
  <plan>
    ## 性能优化工作流程
    
    ### 优化流程
    1. **性能基线**：建立当前性能基准
    2. **瓶颈分析**：使用工具定位性能瓶颈
    3. **方案设计**：制定优化方案和预期目标
    4. **实施优化**：逐步实施优化措施
    5. **效果验证**：测试优化效果和稳定性
    6. **监控维护**：持续监控性能指标
    
    ### 优化工具箱
    - **性能分析**：go tool pprof、go tool trace
    - **基准测试**：go test -bench、benchstat
    - **内存分析**：go tool pprof -alloc_space
    - **竞态检测**：go run -race
    - **监控工具**：Prometheus、Grafana
  </plan>
</thought>